var Ot=Object.defineProperty,xt=Object.defineProperties;var It=Object.getOwnPropertyDescriptors;var ne=Object.getOwnPropertySymbols;var Ue=Object.prototype.hasOwnProperty,Le=Object.prototype.propertyIsEnumerable;var Ie=(e,t,r)=>t in e?Ot(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,A=(e,t)=>{for(var r in t||(t={}))Ue.call(t,r)&&Ie(e,r,t[r]);if(ne)for(var r of ne(t))Le.call(t,r)&&Ie(e,r,t[r]);return e},x=(e,t)=>xt(e,It(t));var Lr=(e,t)=>{var r={};for(var o in e)Ue.call(e,o)&&t.indexOf(o)<0&&(r[o]=e[o]);if(e!=null&&ne)for(var o of ne(e))t.indexOf(o)<0&&Le.call(e,o)&&(r[o]=e[o]);return r};var v=(e,t,r)=>new Promise((o,s)=>{var n=i=>{try{l(r.next(i))}catch(d){s(d)}},c=i=>{try{l(r.throw(i))}catch(d){s(d)}},l=i=>i.done?o(i.value):Promise.resolve(i.value).then(n,c);l((r=r.apply(e,t)).next())});import*as re from"expo-apple-authentication";import{applicationId as wt}from"expo-application";import*as Y from"expo-linking";import*as U from"expo-secure-store";import*as oe from"expo-web-browser";import{useCallback as ht,useContext as Rr,useEffect as Wr}from"react";import{Platform as Ae}from"react-native";import{PrivyClientError as j}from"@privy-io/js-sdk-core";import{digest as Sr}from"expo-crypto";import te,{useState as S,useMemo as Er,createContext as Ar,useCallback as pe,useRef as V,useEffect as ut}from"react";import{AppState as pt,View as Cr}from"react-native";import kr,{PrivyClientError as Pr}from"@privy-io/js-sdk-core";var Me={name:"@privy-io/expo",version:"0.34.7",description:"Expo client for the Privy Auth API",keywords:["authentication","authorization","identity","privacy","privy","user data","react-native","expo","web3"],license:"Apache-2.0",author:"privy.io",exports:{".":{require:"./dist/index.js",import:"./dist/esm/index.js",types:"./dist/index.d.ts"},"./passkey":{require:"./dist/passkey.js",import:"./dist/esm/passkey.js",types:"./dist/passkey.d.ts"},"./smart-wallets":{require:"./dist/smart-wallets.js",import:"./dist/esm/smart-wallets.js",types:"./dist/smart-wallets.d.ts"}},main:"./dist/esm/index.js",source:"./src/index.ts",types:"./dist/index.d.ts",files:["dist/**/*","LICENSE","README.md"],scripts:{build:"npx tsup --clean --minify","check-types":"npx tsc --noEmit",clean:"rm -rf dist .turbo",dev:"npx tsup --watch",format:'eslint "src/**/*.{ts,tsx,js,jsx}" --fix',"generate-types":"npx tsup --dts-only",lint:'npx eslint "src/**/*.{ts,tsx,js,jsx}"',test:'jest --testMatch "**/test/**/*.test.{ts,tsx}"'},browserslist:["defaults","node >= 18","not op_mini all"],dependencies:{"@privy-io/js-sdk-core":"0.35.5","react-fast-compare":"^3.2.2",zustand:"^4.4.1"},devDependencies:{"@privy-io/eslint-config-custom":"*","@privy-io/tsconfig":"*","@simplewebauthn/types":"9.0.1","@svgr/core":"^8.1.0","@svgr/plugin-jsx":"^8.1.0","@svgr/plugin-svgo":"^8.1.0","@testing-library/react-native":"^12.8.1","@tsconfig/node16-strictest-esm":"^1.0.3","@types/jest":"^29.1.2",buffer:"^5.4.3","eslint-plugin-react-hooks":"^5.0.0-canary-7118f5dd7-20230705",jest:"^29.7.0","jest-expo":"~51.0.0",tsup:"^6.2.3",typescript:"~5.5.3"},peerDependencies:{"@expo-google-fonts/inter":"*","@privy-io/expo-native-extensions":"0.0.3","expo-apple-authentication":"*","expo-application":"*","expo-clipboard":"*","expo-constants":"*","expo-crypto":"*","expo-font":"*","expo-linking":"*","expo-secure-store":"*","expo-web-browser":"*",permissionless:"^0.2.10",react:"*","react-native":"*","react-native-passkeys":"^0.3.0","react-native-qrcode-styled":"*","react-native-safe-area-context":"*","react-native-svg":"*","react-native-webview":"*",viem:"^2.21.36"},peerDependenciesMeta:{"@expo-google-fonts/inter":{optional:!0},"expo-font":{optional:!0},permissionless:{optional:!0},viem:{optional:!0}},publishConfig:{access:"public"}};import Lt from"react";import{useCallback as Mt,useEffect as Te,useRef as Tt}from"react";import{AppState as Ft}from"react-native";import jt from"react-native-webview";var Fe=({client:e,isClientReady:t,setWebViewState:r,webViewState:o,logLevel:s})=>{let n=Tt(null);Te(()=>{n.current&&o==="loaded"&&e.setMessagePoster(n.current)},[e,n.current,o==="loaded"]),Te(()=>Ft.addEventListener("change",i=>v(void 0,null,function*(){n.current&&i==="active"&&((yield e.embeddedWallet.ping(500))||(n.current.reload(),r("reloading")))})).remove,[]);let c=Mt(l=>v(void 0,null,function*(){let{data:i}=l.nativeEvent;e.embeddedWallet.onMessage(JSON.parse(i))}),[e]);return t?Lt.createElement(jt,{style:{flex:1},ref:n,cacheEnabled:!1,cacheMode:"LOAD_NO_CACHE",source:{uri:e.embeddedWallet.getURL()},webviewDebuggingEnabled:s==="DEBUG",onLoad:()=>r("loaded"),onError:console.error,onMessage:c}):null};import{useCallback as we,useEffect as Ve,useMemo as he}from"react";import{errorIndicatesRecoveryIsNeeded as Dt,getAllUserEmbeddedSolanaWallets as Vt,getUserEmbeddedEthereumWallet as Kt,getUserEmbeddedSolanaWallet as qt,PrivyClientError as $}from"@privy-io/js-sdk-core";import{getAllUserEmbeddedSolanaWallets as je,getUserEmbeddedWallet as Nt,PrivyClientError as ie}from"@privy-io/js-sdk-core";function Ne(n){return v(this,arguments,function*({client:e,setSolanaWallet:t,createSolanaWalletCallbacks:r,setSolanaRecoveryFlowState:o,opts:s}){var c,l,i;t({status:"creating"});try{let{user:d}=yield e.user.get(),a=je(d),u=a[0];if(s!=null&&s.recoveryMethod&&s.recoveryMethod!=="privy")throw new ie({code:"embedded_wallet_creation_error",error:"Unsupported recovery method for solana wallet."});if(!(s!=null&&s.createAdditional)&&u)throw new ie({code:"embedded_wallet_creation_error",error:"Solana wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let m,f;if(u){let w=Math.max(...a.map(_=>_.wallet_index),0)+1,p=yield e.embeddedWallet.createAdditionalSolana({primaryPublicKey:u.address,hdWalletIndex:w});m=p.provider,f=p.user}else{let w=(c=Nt(d))!=null?c:void 0,p=yield e.embeddedWallet.createSolana({ethereumAccount:w});m=p.provider,f=p.user}let y=je(f)[0];if(!y)throw new ie({code:"embedded_wallet_creation_error",error:"Unknown error creating solana wallet"});return(i=(l=r.current)==null?void 0:l.onSuccess)==null||i.call(l,m),t({status:"connected",publicKey:y.public_key}),o({status:"initial"}),m}catch(d){let a=d instanceof Error?d.message:"Error creating embedded wallet";throw t({status:"error",error:a}),o({status:"initial"}),new ie({code:"embedded_wallet_creation_error",error:a})}})}import{PrivyClientError as H}from"@privy-io/js-sdk-core";function ae(d){return v(this,arguments,function*({client:e,account:t,setWallet:r,recoverWalletCallbacks:o,recoveryMethod:s,setRecoveryFlowState:n,password:c,recoveryToken:l,recoverySecretOverride:i}){var a,u,m,f;if(!t)throw new H({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});switch(s){case"user-passcode":if(!c)throw new H({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!l)throw new H({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!i)throw new H({code:"embedded_wallet_recovery_error",error:"Record name is required for icloud recovery method"});break}r({status:"connecting",account:t});try{let y=yield e.embeddedWallet.getProvider(t,c,l,i);return r({status:"connected",provider:y,account:t}),n({status:"initial"}),(u=(a=o.current)==null?void 0:a.onSuccess)==null||u.call(a,y),y}catch(y){r({status:"needs-recovery",account:t}),n({status:"initial"});let w=new H({code:"embedded_wallet_recovery_error",error:y instanceof Error?y.message:"Error recovering embedded wallet"});throw(f=(m=o.current)==null?void 0:m.onError)==null||f.call(m,w),w}})}function De(l){return v(this,arguments,function*({client:e,account:t,entropyId:r,entropyIdVerifier:o,setSolanaWallet:s,recoverSolanaWalletCallbacks:n,setSolanaRecoveryFlowState:c}){var i,d,a,u;s({status:"connecting"});try{let m=yield e.embeddedWallet.getSolanaProvider(t,r,o);return s({status:"connected",publicKey:m._publicKey}),c({status:"initial"}),(d=(i=n.current)==null?void 0:i.onSuccess)==null||d.call(i,m),m}catch(m){s({status:"needs-recovery"}),c({status:"initial"});let f=new H({code:"embedded_wallet_recovery_error",error:m instanceof Error?m.message:"Error recovering embedded wallet"});throw(u=(a=n.current)==null?void 0:a.onError)==null||u.call(a,f),f}})}var se=e=>{if(e.chain_type==="ethereum")return{entropyId:e.address,entropyIdVerifier:"ethereum-address-verifier"};if(e.chain_type==="solana")return{entropyId:e.address,entropyIdVerifier:"solana-address-verifier"};throw new Error("Invalid embedded wallet account type")};var Ke=({client:e,user:t,solanaWallet:r,setSolanaWallet:o,setSolanaRecoveryFlowState:s,webViewState:n,createSolanaWalletCallbacks:c,recoverSolanaWalletCallbacks:l})=>{let i=he(()=>Vt(t),[t]),d=he(()=>{var y;return i.length===0?null:(y=Kt(t))!=null?y:qt(t)},[t,i]),a=he(()=>{if(!d)return[];let{entropyId:y,entropyIdVerifier:w}=se(d);return i.map(p=>({address:p.address,publicKey:p.address,walletIndex:p.wallet_index,getProvider:()=>e.embeddedWallet.getSolanaProvider(p,y,w)}))},[i,d,e]),u=we(y=>v(void 0,null,function*(){return yield Ne({client:e,setSolanaWallet:o,createSolanaWalletCallbacks:c,setSolanaRecoveryFlowState:s,opts:y})}),[e,c]),m=we(()=>v(void 0,null,function*(){if(!d)throw new $({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{entropyId:y,entropyIdVerifier:w}=se(d);return De({client:e,account:i[0],entropyId:y,entropyIdVerifier:w,setSolanaWallet:o,recoverSolanaWalletCallbacks:l,setSolanaRecoveryFlowState:s})}),[e,d,i,l,s,o]),f=we(()=>v(void 0,null,function*(){if(!d)throw o({status:"not-created"}),new $({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});o(y=>y.status==="connected"?{status:"reconnecting"}:{status:"connecting"});try{let{entropyId:y,entropyIdVerifier:w}=se(d),p=yield e.embeddedWallet.getSolanaProvider(i[0],y,w);return o({status:"connected",publicKey:i[0].public_key}),p}catch(y){throw Dt(y)?(o({status:"needs-recovery"}),new $({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):y instanceof Error?(o({status:"error",error:y.message}),new $({code:"unknown_embedded_wallet_error",error:y.message})):(o({status:"error",error:"Error loading embedded wallet"}),new $({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,d]);return Ve(()=>{if(!t&&r.status!=="disconnected")return o({status:"disconnected"});n==="loaded"&&f().catch(()=>{})},[n,t,d]),Ve(()=>{r.status==="error"&&r.error.includes("User must be logged in")&&f()},[r.status]),{create:u,recover:m,getProvider:f,wallets:a}};import{useCallback as ee,useEffect as Ye,useMemo as er}from"react";import{getUserEmbeddedSolanaWallet as Xe,throwIfInvalidRecoveryUpgradePath as tr}from"@privy-io/js-sdk-core";import{errorIndicatesRecoveryIsNeeded as rr,getUserEmbeddedWallet as or,PrivyClientError as k}from"@privy-io/js-sdk-core";import{getUserEmbeddedWallet as Ht}from"@privy-io/js-sdk-core";import{PrivyClientError as le}from"@privy-io/js-sdk-core";function de(a){return v(this,arguments,function*({client:e,setWallet:t,createWalletCallbacks:r,recoveryMethod:o,setRecoveryFlowState:s,password:n,recoveryToken:c,recoverySecretOverride:l,iCloudRecordNameOverride:i,solanaAccount:d}){var m,f;switch(o){case"user-passcode":if(!n)throw new le({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!c)throw new le({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!l||!i)throw new le({code:"embedded_wallet_recovery_error",error:"iCloud recovery failed due to inability to store credentials"});break}t({status:"creating",account:null});let u=o==="icloud"?"icloud-native":o;try{let{provider:y,user:w}=yield e.embeddedWallet.create(n,u,c,l,i,d),p=Ht(w);return(f=(m=r.current)==null?void 0:m.onSuccess)==null||f.call(m,y),t({status:"connected",provider:y,account:p}),s({status:"initial"}),y}catch(y){let w=y instanceof Error?y.message:"Error creating embedded wallet";throw t({status:"error",error:w,account:null}),s({status:"initial"}),new le({code:"embedded_wallet_creation_error",error:w})}})}import{Platform as qe}from"react-native";import{PrivyClientError as M}from"@privy-io/js-sdk-core";function He(){return v(this,null,function*(){try{return yield import("@privy-io/expo-native-extensions")}catch(e){throw new Error("@privy-io/expo-native-extensions not found. Ensure that you're explicitly including as a dependency, and running an Expo development build")}})}function ge(o){return v(this,arguments,function*({user:e,appId:t,client:r}){var l;if(qe.OS==="android")throw new M({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let s=yield He(),n=yield r.recovery.icloudAuth.getICloudConfiguration("expo-ios");if(!(n==null?void 0:n.container_identifier))throw new M({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:i,iCloudRecordName:d}=yield s.writeRecoverySecretToICloud({containerId:n.container_identifier,appId:t,userId:e.id});return{recoverySecret:i,iCloudRecordName:d}}catch(i){if(i instanceof Error){let d=(l=i.message.split("Caused by: ")[1])!=null?l:"Error writing to iCloud";throw new M({code:"embedded_wallet_recovery_error",error:d})}throw new M({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}function ze(o){return v(this,arguments,function*({walletAddress:e,client:t,chainType:r}){var d;if(qe.OS==="android")throw new M({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let s=yield He(),c=(yield t.recovery.getRecoveryKeyMaterial(e,r)).icloud_record_name;if(!c)throw new M({code:"embedded_wallet_recovery_error",error:"iCloud recovery not properly backed up."});let l=yield t.recovery.icloudAuth.getICloudConfiguration("expo-ios"),i=l==null?void 0:l.container_identifier;if(!i)throw new M({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:a}=yield s.readRecoverySecretFromICloud({containerId:i,recordName:c});return{recoverySecret:a}}catch(a){if(a instanceof Error){let u=(d=a.message.split("Caused by: ")[1])!=null?d:"Error writing to iCloud";throw new M({code:"embedded_wallet_recovery_error",error:u})}throw new M({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}import*as D from"expo-linking";import*as Je from"expo-web-browser";import{Platform as Ge}from"react-native";import{PrivyClientError as z}from"@privy-io/js-sdk-core";import zt from"react-fast-compare";var Be=e=>t=>e(r=>zt(r,t)?r:t);import{PrivyApiError as Bt,PrivyClientError as Jt}from"@privy-io/js-sdk-core";function I(e){return e instanceof Error||e instanceof Bt||e instanceof Jt?e:typeof e=="string"?new Error(e):new Error("Unknown error")}var fo=e=>new Promise(t=>setTimeout(t,e));import{useEffect as Gt,useRef as Yt}from"react";import{AppState as be}from"react-native";function _o(){let e=Yt(be.currentState);Gt(()=>be.addEventListener("change",o=>{e.current=o}).remove,[]);function t(){return be.currentState}return{appState:e,getCurrentAppState:t}}function Z(s){return v(this,arguments,function*({provider:e,redirectUri:t,client:r,onError:o}){try{let n;switch(e){case"google-drive":{let{url:d}=yield r.recovery.auth.generateURL(D.createURL(t||"/"));n=d;break}default:throw new z({error:"OAuth invalid provider",code:"embedded_wallet_recovery_error"})}let c=yield Je.openAuthSessionAsync(n);if(Ge.OS==="android")return;if(c.type!=="success")throw new z({error:"Recovery OAuth session failed",code:"embedded_wallet_recovery_error"});let{queryParams:l}=D.parse(c.url),i;switch(e){case"google-drive":{let{privy_oauth_state:d,privy_oauth_code:a}=l;if(!a||!d)throw new z({error:"Recovery OAuth invalid credentials",code:"embedded_wallet_recovery_error"});i=yield ce({oAuthCode:a,oAuthState:d,client:r});break}default:throw new z({error:"Recovery OAuth invalid provider",code:"embedded_wallet_recovery_error"})}return i}catch(n){throw o==null||o(I(n)),n}})}function ce(o){return v(this,arguments,function*({oAuthCode:e,oAuthState:t,client:r}){let{access_token:s}=yield r.recovery.auth.authorize(e,t);if(!s)throw new z({error:"OAuth invalid credentials",code:"login_with_oauth_returned_with_invalid_credentials"});return s})}var Xt=2*60*1e3;function Qt(e){let t;return new Promise((r,o)=>{t=D.addEventListener("url",n=>v(this,[n],function*({url:s}){if(!s)return;let{queryParams:c}=D.parse(s),{privy_oauth_state:l,privy_oauth_code:i}=c!=null?c:{};if(typeof i!="string"||typeof l!="string")return;let d=yield ce({client:e,oAuthCode:i,oAuthState:l});r(d)})),setTimeout(()=>{o(new z({code:"embedded_wallet_set_recovery_error",error:"Failed to complete Google Drive recovery flow"}))},Xt)}).finally(()=>{t==null||t.remove()})}function Io(e){return v(this,null,function*(){let t;Ge.OS==="android"&&(t=Qt(e));let r=yield Z({provider:"google-drive",client:e});return r!=null?r:yield t})}import{getUserEmbeddedWallet as $t,PrivyClientError as Zt}from"@privy-io/js-sdk-core";function ue(n){return v(this,arguments,function*({client:e,recoveryInput:t,setWalletRecoveryCallbacks:r,setRecoveryFlowState:o,setWallet:s}){var c,l,i,d;try{let{provider:a,user:u}=yield e.embeddedWallet.setRecovery(t),m=a,f=$t(u);return s({status:"connected",provider:m,account:f}),(l=(c=r.current)==null?void 0:c.onSuccess)==null||l.call(c,m),o({status:"initial"}),m}catch(a){let u=new Zt({code:"embedded_wallet_set_recovery_error",error:a instanceof Error?a.message:"Error setting password on embedded wallet"});throw(d=(i=r.current)==null?void 0:i.onError)==null||d.call(i,u),o({status:"initial"}),u}})}function Qe(e){return e===void 0?{recoveryMethod:"privy"}:typeof e=="string"?{recoveryMethod:"user-passcode",password:e}:e.recoveryMethod==="user-passcode"?{recoveryMethod:"user-passcode",password:e.password}:{recoveryMethod:e.recoveryMethod}}var $e=({client:e,user:t,appId:r,wallet:o,setWallet:s,setRecoveryFlowState:n,webViewState:c,createWalletCallbacks:l,recoverWalletCallbacks:i,setWalletRecoveryCallbacks:d})=>{let a=er(()=>or(t),[t]),u=ee(p=>v(void 0,null,function*(){var W,q;if(a)throw new k({error:"This user already has an embedded wallet",code:"embedded_wallet_already_exists"});let{user:_}=yield e.user.get(),{password:g,recoveryMethod:h}=Qe(p),b,E,O;if(h==="google-drive"&&(b=yield Z({provider:h,client:e,onError:(W=l.current)==null?void 0:W.onError}),n({status:"creating-wallet"}),!b))return null;if(h==="icloud"){if(!_)throw new k({code:"embedded_wallet_recovery_error",error:"User must be loaded before creating a wallet with iCloud."});let{recoverySecret:T,iCloudRecordName:N}=yield ge({user:_,appId:r,client:e});E=T,O=N}return yield de({client:e,setWallet:s,createWalletCallbacks:l,recoveryMethod:h,setRecoveryFlowState:n,password:g,recoverySecretOverride:E,iCloudRecordNameOverride:O,solanaAccount:(q=Xe(_))!=null?q:void 0})}),[e,a,t]),m=ee(p=>v(void 0,null,function*(){var h;if(o.status!=="connected")throw new k({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"});if(!a)throw new k({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});if(Xe(t))throw new k({code:"embedded_wallet_set_recovery_error",error:"Cannot set user-controlled recovery for a user with an embedded Solana wallet."});tr({currentRecoveryMethod:a.recovery_method,upgradeToRecoveryMethod:p.recoveryMethod});let _,g;switch(p.recoveryMethod){case"privy":g=x(A({},p),{wallet:a});break;case"user-passcode":g=x(A({},p),{wallet:a,password:p.password});break;case"google-drive":if(_=yield Z({provider:p.recoveryMethod,client:e,onError:(h=d.current)==null?void 0:h.onError}),n({status:"upgrading-recovery"}),!_)return null;g={recoveryMethod:"google-drive",wallet:a,recoveryAccessToken:_};break;case"icloud":if(!t)throw new k({code:"embedded_wallet_recovery_error",error:"User must be loaded before backing up to iCloud."});let{recoverySecret:b,iCloudRecordName:E}=yield ge({user:t,appId:r,client:e});g={recoveryMethod:"icloud-native",recoverySecretOverride:b,iCloudRecordNameOverride:E,wallet:a};break;default:throw new k({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}return ue({client:e,recoveryInput:g,setWalletRecoveryCallbacks:d,setRecoveryFlowState:n,setWallet:s})}),[e,a,o.status,t]),f=ee(p=>v(void 0,null,function*(){return m({recoveryMethod:"user-passcode",password:p})}),[e,a,o.status]),y=ee(p=>v(void 0,null,function*(){var E;if(!a)throw new k({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{password:_,recoveryMethod:g}=Qe(p),h,b;if(g==="google-drive"&&(h=yield Z({provider:g,client:e,onError:(E=i.current)==null?void 0:E.onError}),n({status:"recovering"}),!h))return null;if(g==="icloud"){if(!t)throw new k({code:"embedded_wallet_recovery_error",error:"User must be loaded before recovering via iCloud."});let{recoverySecret:O}=yield ze({client:e,walletAddress:a.address});b=O}return ae({client:e,account:a,setWallet:s,recoverWalletCallbacks:i,recoveryMethod:g,setRecoveryFlowState:n,password:_,recoveryToken:h,recoverySecretOverride:b})}),[e,a]),w=ee(()=>v(void 0,null,function*(){if(!a)throw s({status:"not-created",account:null}),new k({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});s(p=>p.status==="connected"?{status:"reconnecting",account:a}:{status:"connecting",account:a});try{let p=yield e.embeddedWallet.getProvider(a);return s({status:"connected",provider:p,account:a}),p}catch(p){throw rr(p)?(s({status:"needs-recovery",account:a}),new k({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):p instanceof Error?(s({status:"error",error:p.message,account:a}),new k({code:"unknown_embedded_wallet_error",error:p.message})):(s({status:"error",error:"Error loading embedded wallet",account:a}),new k({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,a]);return Ye(()=>{if(!t&&o.status!=="disconnected")return s({status:"disconnected",account:null});c==="loaded"&&w().catch(()=>{})},[c,t,a]),Ye(()=>{o.status==="error"&&o.error.includes("User must be logged in")&&w()},[o.status]),{create:u,recover:y,setPassword:f,setRecovery:m,getProvider:w}};import{useEffect as nr,useState as ir}from"react";import{PrivyClientError as Ze}from"@privy-io/js-sdk-core";var et=({client:e,user:t,isReady:r,customAuth:o})=>{let[s,n]=ir({status:"initial"});return nr(()=>{(()=>v(void 0,null,function*(){if(!(o!=null&&o.enabled)){n({status:"not-enabled"});return}n({status:"loading"});let{getCustomAccessToken:l,isLoading:i}=o;if(!(!r||i))try{let d=yield l();if(!d&&t){yield e.auth.logout(),n({status:"done"});return}if(!d){n({status:"done"});return}if(t){n({status:"done"});return}if(!(yield e.auth.customProvider.syncWithToken(d))){yield e.auth.logout(),n({status:"error",error:new Ze({error:"Failed to sync with custom auth provider",code:"third_party_auth_error"})});return}n({status:"done"})}catch(d){if(console.log("Error syncing with custom auth provider",d),n({status:"error",error:d}),t)throw yield e.auth.logout(),new Ze({error:"Third-party auth failed",code:"third_party_auth_error"})}}))()},[e,t,r,o==null?void 0:o.enabled,o==null?void 0:o.getCustomAccessToken,o==null?void 0:o.isLoading]),{customAuthState:s,customAuthStateIsSettled:s.status!=="loading"&&s.status!=="initial"}};import*as B from"expo-linking";import{useCallback as ar,useEffect as sr}from"react";import{Platform as lr}from"react-native";var tt=({client:e,user:t,isUserInitialized:r,oAuthState:o,oAuthCallbacks:s,setOAuthState:n,recoveryFlowState:c,oAuthStateRef:l})=>{let i=B.useURL(),d=ar(a=>{var m,f;let u=I(a);n({status:"error",error:u}),(f=(m=s.current).onError)==null||f.call(m,u)},[n]);return sr(()=>{function a(){return v(this,null,function*(){var y,w;if(!i||o.status!=="loading"||c.status!=="initial")return;let{queryParams:u}=B.parse(i),{privy_oauth_state:m,privy_oauth_code:f}=u;if(!f||!m){n({status:"done"});return}try{let p,_;if(t)p=yield e.auth.oauth.linkWithCode(f,m);else{let g=yield e.auth.oauth.loginWithCode(f,m,void 0,void 0,l.current.disableSignup?"no-signup":"login-or-sign-up");p=g.user,_=!!g.is_new_user}return(w=(y=s.current).onSuccess)==null||w.call(y,p,_),l.current={},n({status:"done"}),yield B.openURL(i.split("?")[0])}catch(p){l.current={},d(p)}})}lr.OS==="android"&&r&&a()},[i,r])};import*as J from"expo-linking";import{useCallback as dr,useEffect as cr,useMemo as ur}from"react";import{Platform as pr}from"react-native";import{getUserEmbeddedSolanaWallet as mr,getUserEmbeddedWallet as yr}from"@privy-io/js-sdk-core";var rt=({client:e,user:t,createWalletCallbacks:r,recoverWalletCallbacks:o,setWalletRecoveryCallbacks:s,recoveryFlowState:n,oAuthState:c,setRecoveryFlowState:l,setWallet:i,appStateVisible:d,webViewLoaded:a})=>{let u=J.useURL(),m=ur(()=>yr(t),[t]),f=dr(y=>{var p,_,g,h;let w=I(y);n.status==="creating-wallet"?(_=(p=r.current).onError)==null||_.call(p,I(w)):(h=(g=o.current).onError)==null||h.call(g,I(w)),l({status:"initial"})},[n]);return cr(()=>{function y(){return v(this,null,function*(){var g;if(!u&&n.status!=="initial"&&d&&f(new Error("Recovery OAuth session failed")),!u||n.status==="initial"||c.status!=="initial"||!d||!a)return;let{queryParams:w}=J.parse(u),{privy_oauth_state:p,privy_oauth_code:_}=w;if(!(!_||!p)){yield J.openURL(u.split("?")[0]);try{let h=yield ce({oAuthCode:_,oAuthState:p,client:e});if(n.status==="creating-wallet"){let b=(g=mr(t))!=null?g:void 0;yield de({client:e,setWallet:i,createWalletCallbacks:r,recoveryMethod:"google-drive",setRecoveryFlowState:l,recoveryToken:h,solanaAccount:b})}else if(n.status==="upgrading-recovery"){if(!m)throw new Error("Embedded wallet not found");yield ue({client:e,recoveryInput:{recoveryMethod:"google-drive",wallet:m,recoveryAccessToken:h},setWalletRecoveryCallbacks:s,setRecoveryFlowState:l,setWallet:i})}else yield ae({client:e,account:m,setWallet:i,recoverWalletCallbacks:o,recoveryMethod:"google-drive",setRecoveryFlowState:l,recoveryToken:h})}catch(h){f(h)}}})}pr.OS==="android"&&y()},[u,n.status,d,a])};import{useEffect as vr}from"react";var ot=({client:e,isUserInitialized:t,setIsUserInitialized:r,setError:o})=>{vr(()=>{t||(()=>v(void 0,null,function*(){try{yield e.initialize()}catch(n){o(n instanceof Error?n:new Error(String(n)))}try{yield e.user.get()}catch(n){}finally{r(!0)}}))()},[e,t,o,r])};import{create as gr}from"zustand";var P=class extends Error{constructor(r,o){super(o);this.code=r,this.error=o}},nt=class extends P{constructor(r){super("underlying_error",r instanceof Error?r.message:"An underlying error occurred");this.wrappedError=r}};var _e={success:e=>({value:e}),error:e=>({error:e})};var it=e=>{let t=Array.from(new Set(e));return t.length===0?_e.error(new P("no_login_methods_available","No login methods available")):_e.success(t)},Se=e=>{let t=e.length,r=e.every(o=>o==="sms"||o==="email");return t<=2&&r?e[0]:null},_n=(e,t)=>{if(e.length!==2)return null;let[r,o]=e;return t===r?o:r},Sn={email:"email",sms:"phone",google:"Google",apple:"Apple",discord:"Discord",twitter:"X",github:"Github",spotify:"Spotify",instagram:"Instagram",tiktok:"Tiktok",linkedin:"LinkedIn"};import{useEffect as fr}from"react";import{createStore as wr}from"zustand/vanilla";var at=wr()(e=>({isUIMounted:!1,updateUIMounted:t=>e({isUIMounted:t})})),st=()=>{let{isUIMounted:e}=at.getState();if(!e)throw new P("privy_elements_not_ready","Privy Elements is not mounted")},Pn=()=>{fr(()=>{let{updateUIMounted:e}=at.getState();return e(!0),()=>{e(!1)}},[])};function lt(e){return new Promise((t,r)=>{e({resolve:t,reject:r})})}function hr(e,t){return{resolve:r=>{t(),e.resolve(r)},reject:r=>{t(),e.reject(r)}}}function dt(e,t,r){let o=setTimeout(()=>{e.reject(t())},r);return hr(e,()=>{clearTimeout(o)})}var br=1e3*60*5,G=gr()((e,t)=>({privyElementsConfig:null,loginPromiseResolvers:null,activeLoginMethod:null,openLoginFlow:(r,o,s,n)=>lt(c=>{var u,m,f;let l=o.app.getConfig();if(!l)return c.reject(new P("privy_not_ready","Privy is not ready"));if(s!==null)return c.reject(new P("user_already_logged_in","User is already logged in"));if(st(),t().loginPromiseResolvers!==null)return c.reject(new P("existing_login_flow_in_progress","A login flow is already in progress"));let i=it(r.loginMethods);if(i.error)return c.reject(i.error);let d={loginMethods:i.value,appearance:{logo:(f=(m=(u=r.appearance)==null?void 0:u.logo)!=null?m:l.logo_url)!=null?f:void 0}},a=dt(c,()=>(e({privyElementsConfig:null,loginPromiseResolvers:null}),new P("login_flow_timeout","The login flow timed out")),br);n(),e({loginPromiseResolvers:a,privyElementsConfig:d,activeLoginMethod:Se(d.loginMethods)})}),closeLoginFlow:()=>{var r;return(r=t().loginPromiseResolvers)==null||r.reject(new P("login_flow_closed","The login flow was closed")),e({privyElementsConfig:null,loginPromiseResolvers:null})},goBack:()=>{let{activeLoginMethod:r,privyElementsConfig:o,updateActiveLoginMethod:s,closeLoginFlow:n}=t();if(!o){n();return}let c=Se(o.loginMethods)===null;r===null||!c?n():s(null)},updateActiveLoginMethod:r=>e({activeLoginMethod:r})})),Mn=()=>G(e=>e.privyElementsConfig),Tn=()=>G(e=>e.openLoginFlow),Fn=()=>G(e=>e.closeLoginFlow),jn=()=>G(e=>e.goBack),Nn=()=>G(e=>[e.activeLoginMethod,e.updateActiveLoginMethod]),_r=e=>{let{loginPromiseResolvers:t}=G.getState();t==null||t.resolve(e)},ct=()=>_r;var Ee=Ar({}),K;function ri(e){return K?K.getAccessToken():e!=null&&e.strict?Promise.reject(new Pr({code:"attempted_to_read_storage_before_client_initialized",error:"Called `getAccessToken` before client initialized"})):(console.warn("Called `getAccessToken` before client initialized"),Promise.resolve(null))}var oi=e=>{var Oe,xe;let[t,r]=S(pt.currentState==="active");ut(()=>{let R=pt.addEventListener("change",Wt=>{r(Wt==="active")});return()=>{R.remove()}},[]);let[o,s]=S(!1),[n,c]=S(null),[l,i]=S("loading"),[d,a]=S(!1),[u,m]=S(null),[f,y]=S({status:"disconnected",account:null}),[w,p]=S({status:"disconnected"}),[_,g]=S({status:"initial"}),[h,b]=S({status:"initial"}),E=V({}),[O,W]=S({status:"initial"}),[q,T]=S({status:"initial"}),[N,X]=S({status:"initial"}),[me,F]=S({status:"initial"}),[L,gt]=S({status:"initial"}),[bt,_t]=S();ut(()=>{var R;return _t((R=e.config)==null?void 0:R.mfa)},[(Oe=e.config)==null?void 0:Oe.mfa]);let Pe=V({}),ye=V({}),ve=V({}),fe=V({}),Re=V({}),We=V({}),St=ct(),Q=pe(R=>{if(R){St(R),Be(m)(R);return}m(null),g({status:"initial"}),b({status:"initial"}),y({status:"disconnected",account:null})},[]),C=Er(()=>{let R=e.storage||ft;return e.client?(K=e.client,K.setCallbacks({setUser:Q,setIsReady:a}),K):(K=new kr({storage:vt(R),appId:e.appId,clientId:e.clientId,supportedChains:e.supportedChains,nativeAppIdentifier:yt(),baseUrl:e.baseUrl,sdkVersion:`expo:${Me.version}`,callbacks:{setUser:Q,setIsReady:a},logLevel:e.logLevel,crypto:{digest:Sr}}),K)},[e.client,e.storage,e.appId,e.clientId,e.baseUrl,e.supportedChains,e.logLevel,Q]),Et=pe(()=>(Q(null),C.auth.logout()),[Q,C]),At=pe(()=>v(void 0,null,function*(){try{return yield C.getAccessToken()}catch(R){return console.debug(R),null}}),[C]),Ct=pe(()=>C.getIdentityToken(),[C]);ot({client:C,isUserInitialized:o,setIsUserInitialized:s,setError:c});let kt=$e({client:C,user:u,appId:e.appId,webViewState:l,createWalletCallbacks:ye,recoverWalletCallbacks:ve,setWalletRecoveryCallbacks:fe,setRecoveryFlowState:W,wallet:f,setWallet:y}),Pt=Ke({client:C,user:u,webViewState:l,createSolanaWalletCallbacks:Re,recoverSolanaWalletCallbacks:We,setSolanaRecoveryFlowState:T,solanaWallet:w,setSolanaWallet:p});tt({client:C,isUserInitialized:o,user:u,oAuthState:h,setOAuthState:b,oAuthCallbacks:Pe,recoveryFlowState:O,oAuthStateRef:E}),rt({client:C,user:u,webViewLoaded:l==="loaded",createWalletCallbacks:ye,recoverWalletCallbacks:ve,setWalletRecoveryCallbacks:fe,recoveryFlowState:O,oAuthState:h,setRecoveryFlowState:W,setWallet:y,appStateVisible:t});let{customAuthStateIsSettled:Rt}=et({client:C,user:u,isReady:o,customAuth:(xe=e.config)==null?void 0:xe.customAuth});return te.createElement(te.Fragment,null,te.createElement(Ee.Provider,{value:{client:C,user:u,isReady:l!=="loading"&&o&&mt(h)&&Rt,error:n,logout:Et,getAccessToken:At,getIdentityToken:Ct,wallet:A(A({},f),kt),solanaWallet:A(A({},w),Pt),oAuthState:h,oAuthCallbacks:Pe,recoveryFlowState:O,setRecoveryFlowState:W,solanaRecoveryFlowState:q,setSolanaRecoveryFlowState:T,createWalletCallbacks:ye,recoverWalletCallbacks:ve,setWalletRecoveryCallbacks:fe,createSolanaWalletCallbacks:Re,recoverSolanaWalletCallbacks:We,setOAuthState:b,siweState:N,setSiweState:X,otpState:_,setOtpState:g,passkeyState:me,setPasskeyState:F,farcasterState:L,setFarcasterState:gt,oAuthStateRef:E,mfaConfig:bt}},e.children),te.createElement(Cr,{style:{width:0,height:0,overflow:"hidden"}},te.createElement(Fe,{logLevel:e.logLevel,client:C,isClientReady:d,setWebViewState:i,webViewState:l})))};var mt=e=>e.status!=="loading",Ce=(e={})=>{let{user:t,oAuthState:r,setOAuthState:o,oAuthCallbacks:s,client:n,oAuthStateRef:c}=Rr(Ee),l=e.action?e.action==="login":!t;Wr(()=>{s.current={onSuccess:e.onSuccess,onError:e.onError}},[e.onSuccess,e.onError]);let i=ht(a=>{var m;let u=I(a);return o({status:"error",error:u}),(m=e==null?void 0:e.onError)==null||m.call(e,u),u},[e==null?void 0:e.onError]);return{start:ht(function(w){return v(this,arguments,function*({provider:u,redirectUri:m,isLegacyAppleIosBehaviorEnabled:f=!1,disableSignup:y}){var p,_,g;o({status:"loading"}),c.current={disableSignup:y};try{if(t&&e.action==="login")throw new j({code:"attempted_login_with_oauth_while_already_logged_in",error:"Already logged in, if trying to link an OAuth account use `useLinkWithOAuth`"});if(!t&&e.action==="link")throw new j({code:"attempted_link_oauth_before_logged_in",error:"Must be logged in to link an OAuth account, use `useLoginWithOAuth`"});let{url:h}=yield n.auth.oauth.generateURL(u,Y.createURL(m||"/")),b,E;if(Ae.OS==="ios"&&u==="apple"&&!f){let me=(p=new URL(h).searchParams.get("state"))!=null?p:"",F=yield re.signInAsync({state:me,requestedScopes:[re.AppleAuthenticationScope.EMAIL,re.AppleAuthenticationScope.FULL_NAME]}).catch(L=>{throw L instanceof Error&&"code"in L&&L.code==="ERR_REQUEST_CANCELED"?new j({error:"Apple login was cancelled",code:l?"login_with_oauth_was_cancelled_by_user":"link_with_oauth_was_cancelled_by_user"}):L});if(!F.authorizationCode||!F.state)throw new j({error:"OAuth invalid credentials",code:l?"login_with_oauth_returned_with_invalid_credentials":"link_with_oauth_returned_with_invalid_credentials"});if(l){let L=yield n.auth.oauth.loginWithCode(F.authorizationCode,F.state,u,"raw",y?"no-signup":"login-or-sign-up");b=L.user,E=L.is_new_user}else b=yield n.auth.oauth.linkWithCode(F.authorizationCode,F.state,u,"raw");return(_=e==null?void 0:e.onSuccess)==null||_.call(e,b,E),o({status:"done"}),b!=null?b:void 0}let O=Ae.OS==="android"?h.replace("x.com","twitter.com"):h,W=yield oe.openAuthSessionAsync(O);if(Ae.OS==="android")return;if(W.type!=="success")throw[oe.WebBrowserResultType.CANCEL,oe.WebBrowserResultType.DISMISS].includes(W.type)?new j({error:"OAuth was cancelled",code:l?"login_with_oauth_was_cancelled_by_user":"link_with_oauth_was_cancelled_by_user"}):new j({error:"OAuth session failed",code:l?"failed_to_complete_login_with_oauth":"failed_to_complete_link_with_oauth"});let{queryParams:q}=Y.parse(W.url),{privy_oauth_state:T,privy_oauth_code:N}=q;if(!N||!T)throw new j({error:"OAuth invalid credentials",code:l?"login_with_oauth_returned_with_invalid_credentials":"link_with_oauth_returned_with_invalid_credentials"});if(l){let X=yield n.auth.oauth.loginWithCode(N,T,u,void 0,y?"no-signup":"login-or-sign-up");b=X.user,E=X.is_new_user}else b=yield n.auth.oauth.linkWithCode(N,T,u);return(g=e==null?void 0:e.onSuccess)==null||g.call(e,b,E),yield Y.openURL(W.url.split("?")[0]),o({status:"done"}),b!=null?b:void 0}catch(h){i(h)}})},[t,n,o,i]),state:r}};function pi(e){let{state:t,start:r}=Ce(x(A({},e),{action:"login"}));return{state:t,login:r}}function mi(e){let{state:t,start:r}=Ce(x(A({},e),{action:"link"}));return{state:t,link:r}}function yi(e){return Ce(e)}var yt=()=>{if(typeof wt!="string")throw new j({error:"Cannot determine native application ID. Please make sure `expo-application` is installed as a dependency and that `ios.bundleId` or `android.package` is set.",code:"invalid_native_app_id"});return wt};function vt(e){return{get(t){return e.get(t.replaceAll(":","-"))},put(t,r){return e.put(t.replaceAll(":","-"),r)},del(t){return e.del(t.replaceAll(":","-"))},getKeys:()=>v(this,null,function*(){return[]})}}var ft={get(e){return U.getItemAsync(e,{keychainAccessible:U.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},put(e,t){return U.setItemAsync(e,t,{keychainAccessible:U.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},del(e){return U.deleteItemAsync(e,{keychainAccessible:U.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},getKeys:()=>v(void 0,null,function*(){return[]})};import{PrivyClientError as Or}from"@privy-io/js-sdk-core";var xr=e=>v(void 0,null,function*(){var o;let r=yield(yield import("react-native-passkeys")).create({rp:e.rp,user:e.user,challenge:e.challenge,pubKeyCredParams:e.pubKeyCredParams,excludeCredentials:e.excludeCredentials,authenticatorSelection:e.authenticatorSelection,timeout:12e4});if(!r)throw new Or({code:"failed_to_create_passkey",error:"Could not create passkey"});return x(A({},r),{type:(o=r.type)!=null?o:"public-key",clientExtensionResults:{}})});import{PrivyClientError as Ir}from"@privy-io/js-sdk-core";var Ur=e=>v(void 0,null,function*(){var o;let r=yield(yield import("react-native-passkeys")).get({rpId:e.rpId,challenge:e.challenge,allowCredentials:e.allowCredentials,timeout:12e4});if(!r)throw new Ir({code:"no_passkey_found_for_challenge",error:"Could not find a matching passkey to login with"});return x(A({},r),{type:(o=r.type)!=null?o:"public-key",clientExtensionResults:{}})});function Ri(e){var t;return{id:e.id,client_extension_results:{app_id:e.clientExtensionResults.appid,cred_props:e.clientExtensionResults.credProps,hmac_create_secret:e.clientExtensionResults.hmacCreateSecret},raw_id:e.rawId,type:e.type,authenticator_attachment:(t=e.authenticatorAttachment)!=null?t:"platform",response:{authenticator_data:e.response.authenticatorData,client_data_json:e.response.clientDataJSON,signature:e.response.signature,user_handle:e.response.userHandle}}}function Wi(e){var t,r,o,s;return{challenge:e.challenge,rpId:e.rp_id,extensions:{appid:(t=e.extensions)==null?void 0:t.app_id,credProps:(r=e.extensions)==null?void 0:r.cred_props,hmacCreateSecret:(o=e.extensions)==null?void 0:o.hmac_create_secret},timeout:e.timeout,allowCredentials:(s=e.allow_credentials)==null?void 0:s.map(({id:n,type:c,transports:l})=>({id:n,type:c,transports:l})),userVerification:e.user_verification}}export{A as a,x as b,Lr as c,v as d,Me as e,se as f,ge as g,ze as h,I as i,fo as j,_o as k,Io as l,pi as m,mi as n,yi as o,yt as p,vt as q,ft as r,P as s,nt as t,_n as u,Sn as v,st as w,Pn as x,lt as y,dt as z,Mn as A,Tn as B,Fn as C,jn as D,Nn as E,Ee as F,ri as G,oi as H,xr as I,Ur as J,Ri as K,Wi as L};
