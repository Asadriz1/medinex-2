import{F as h,J as ie,K as ae,L as se,a as p,b as te,d as m,f as I,g as oe,h as ne,i as g,j as _,k as M,l as L}from"./chunk-2HSCQXHK.js";import{useCallback as T,useContext as ke}from"react";import{PrivyClientError as Se}from"@privy-io/js-sdk-core";var vr=e=>{let{user:r,client:c,setSiweState:a,siweState:o}=ke(h),n=T(l=>{var u;let y=g(l);return a({status:"error",error:y}),(u=e==null?void 0:e.onError)==null||u.call(e,y),y},[e==null?void 0:e.onError]),t=T(f=>m(void 0,[f],function*({wallet:l,from:{domain:y,uri:u}}){var s;try{a({status:"generating-message"});let d=yield c.auth.siwe.init(l,y,u);return a({status:"awaiting-signature"}),(s=e==null?void 0:e.onGenerateMessage)==null||s.call(e,d.message),d.message}catch(d){throw n(d)}}),[c,n,e==null?void 0:e.onGenerateMessage]),i=T(u=>m(void 0,[u],function*({signature:l,messageOverride:y}){var f;try{if(!r)throw new Se({code:"attempted_link_siwe_before_logged_in",error:"Must be logged in to link a wallet, Use `useLoginWithSiwe` to login with a wallet"});a({status:"submitting-signature"});let s=yield c.auth.siwe.linkWithSiwe(l,void 0,y);return a({status:"done"}),(f=e==null?void 0:e.onSuccess)==null||f.call(e,s),s}catch(s){throw n(s)}}),[r,c,n,e==null?void 0:e.onSuccess]);return{generateSiweMessage:t,linkWithSiwe:i,state:o}};import{useCallback as H,useContext as be}from"react";import{PrivyClientError as Ee}from"@privy-io/js-sdk-core";var Wr=e=>{let{user:r,client:c,setSiweState:a,siweState:o}=be(h),n=H(l=>{var u;let y=g(l);return a({status:"error",error:y}),(u=e==null?void 0:e.onError)==null||u.call(e,y),y},[e==null?void 0:e.onError]),t=H(f=>m(void 0,[f],function*({wallet:l,from:{domain:y,uri:u}}){var s;try{a({status:"generating-message"});let d=yield c.auth.siwe.init(l,y,u);return a({status:"awaiting-signature"}),(s=e==null?void 0:e.onGenerateMessage)==null||s.call(e,d.message),d.message}catch(d){throw n(d)}}),[c,n,e==null?void 0:e.onGenerateMessage]);return{loginWithSiwe:H(f=>m(void 0,[f],function*({signature:l,messageOverride:y,disableSignup:u}){var s;try{if(r)throw new Ee({code:"attempted_login_with_siwe_while_already_logged_in",error:"Already logged in, use `useLinkWithSiwe` if you are trying to link a wallet to an existing account"});a({status:"submitting-signature"});let d=yield c.auth.siwe.loginWithSiwe(l,void 0,y,u?"no-signup":"login-or-sign-up");return a({status:"done"}),(s=e==null?void 0:e.onSuccess)==null||s.call(e,d.user,d.is_new_user),d.user}catch(d){throw n(d)}}),[r,c,n,e==null?void 0:e.onSuccess]),generateSiweMessage:t,state:o}};import{useCallback as ce,useContext as pe}from"react";import{PrivyClientError as _e}from"@privy-io/js-sdk-core";var Or=e=>{let{user:r,client:c}=pe(h),a=ce(n=>{var i;let t=g(n);return(i=e==null?void 0:e.onError)==null||i.call(e,t),t},[e==null?void 0:e.onError]);return{unlinkWallet:ce(t=>m(void 0,[t],function*({address:n}){var i;try{if(!r)throw new _e({code:"attempted_unlink_siwe_before_logged_in",error:"Must be logged in to unlink a wallet, Use `useLoginWithSiwe` to login with a wallet"});let l=yield c.auth.siwe.unlinkWallet(n);return(i=e==null?void 0:e.onSuccess)==null||i.call(e,l),l}catch(l){throw a(l)}}),[r,c,a,e==null?void 0:e.onSuccess])}};import{useCallback as G,useContext as We,useState as Pe}from"react";import{PrivyClientError as le}from"@privy-io/js-sdk-core";var Gr=e=>{let[r,c]=Pe(""),{user:a,client:o,otpState:n,setOtpState:t}=We(h),i=G(u=>{var s;let f=g(u);return t({status:"error",error:f}),(s=e==null?void 0:e.onError)==null||s.call(e,f),f},[e==null?void 0:e.onError]),l=G(f=>m(void 0,[f],function*({email:u}){var s;c(u);try{t({status:"sending-code"});let d=yield o.auth.email.sendCode(u);return t({status:"awaiting-code-input"}),(s=e==null?void 0:e.onSendCodeSuccess)==null||s.call(e,{email:u}),d}catch(d){return i(d),{success:!1}}}),[o,i,e==null?void 0:e.onSendCodeSuccess]),y=G(s=>m(void 0,[s],function*({code:u,email:f}){var d;try{if(!a)throw new le({code:"attempted_link_email_before_logged_in",error:"Must be logged in to link an email, Use `useLoginWithEmail` to login with email"});let v=f||r;if(!v)throw new le({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `linkWithCode`"});t({status:"submitting-code"});let k=yield o.auth.email.linkWithCode(v,u);return t({status:"done"}),(d=e==null?void 0:e.onLinkSuccess)==null||d.call(e,k),k}catch(v){i(v)}}),[a,o,r,i,e==null?void 0:e.onLinkSuccess]);return{sendCode:l,linkWithCode:y,state:n}};import{useCallback as B,useContext as Ce,useState as xe}from"react";import{PrivyClientError as de}from"@privy-io/js-sdk-core";var Jr=e=>{let[r,c]=xe(""),{user:a,client:o,otpState:n,setOtpState:t}=Ce(h),i=B(u=>{var s;let f=g(u);return t({status:"error",error:f}),(s=e==null?void 0:e.onError)==null||s.call(e,f),f},[e==null?void 0:e.onError]),l=B(f=>m(void 0,[f],function*({email:u}){var s;c(u);try{t({status:"sending-code"});let d=yield o.auth.email.sendCode(u);return t({status:"awaiting-code-input"}),(s=e==null?void 0:e.onSendCodeSuccess)==null||s.call(e,{email:u}),d}catch(d){return i(d),{success:!1}}}),[o,i,e==null?void 0:e.onSendCodeSuccess]),y=B(d=>m(void 0,[d],function*({code:u,email:f,disableSignup:s}){var v;try{if(a)throw new de({code:"attempted_login_with_email_while_already_logged_in",error:"Already logged in, use `useLinkWithEmail` if you are trying to link an email to an existing account"});let k=f||r;if(!k)throw new de({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid email before calling `loginWithCode`"});t({status:"submitting-code"});let w=yield o.auth.email.loginWithCode(k,u,s?"no-signup":"login-or-sign-up");return t({status:"done"}),(v=e==null?void 0:e.onLoginSuccess)==null||v.call(e,w.user,w.is_new_user),w==null?void 0:w.user}catch(k){i(k)}}),[a,o,r,i,e==null?void 0:e.onLoginSuccess]);return{sendCode:l,loginWithCode:y,state:n}};import{useCallback as N,useContext as Ue,useState as Me}from"react";import{PrivyClientError as ue}from"@privy-io/js-sdk-core";var Zr=e=>{let[r,c]=Me(""),{user:a,client:o,otpState:n,setOtpState:t}=Ue(h),i=N(u=>{var s;let f=g(u);return t({status:"error",error:f}),(s=e==null?void 0:e.onError)==null||s.call(e,f),f},[e==null?void 0:e.onError]),l=N(f=>m(void 0,[f],function*({phone:u}){var s;c(u);try{t({status:"sending-code"});let d=yield o.auth.phone.sendCode(u);return t({status:"awaiting-code-input"}),(s=e==null?void 0:e.onSendCodeSuccess)==null||s.call(e,{phone:u}),d}catch(d){return i(d),{success:!1}}}),[o,i,e==null?void 0:e.onSendCodeSuccess]),y=N(s=>m(void 0,[s],function*({code:u,phone:f}){var d;try{if(!a)throw new ue({code:"attempted_link_sms_before_logged_in",error:"Must be logged in to link a phone number, Use `useLoginWithSMS` to login with a phone number"});if(!(f||r))throw new ue({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `linkWithCode`"});t({status:"submitting-code"});let k=yield o.auth.phone.linkWithCode(f||r,u);return t({status:"done"}),(d=e==null?void 0:e.onLinkSuccess)==null||d.call(e,k),k}catch(v){i(v)}}),[a,o,r,i,e==null?void 0:e.onLinkSuccess]);return{sendCode:l,linkWithCode:y,state:n}};import{useCallback as j,useContext as Le,useState as Oe}from"react";import{PrivyClientError as me}from"@privy-io/js-sdk-core";var at=e=>{let[r,c]=Oe(""),{user:a,client:o,otpState:n,setOtpState:t}=Le(h),i=j(u=>{var s;let f=g(u);return t({status:"error",error:f}),(s=e==null?void 0:e.onError)==null||s.call(e,f),f},[e==null?void 0:e.onError]),l=j(f=>m(void 0,[f],function*({phone:u}){var s;c(u);try{t({status:"sending-code"});let d=yield o.auth.phone.sendCode(u);return t({status:"awaiting-code-input"}),(s=e==null?void 0:e.onSendCodeSuccess)==null||s.call(e,{phone:u}),d}catch(d){return i(d),{success:!1}}}),[o,i,e==null?void 0:e.onSendCodeSuccess]),y=j(d=>m(void 0,[d],function*({code:u,phone:f,disableSignup:s}){var v;try{if(a)throw new me({code:"attempted_login_with_sms_while_already_logged_in",error:"Already logged in, use `useLinkWithSMS` if you are trying to link a phone number to an existing account"});if(!(f||r))throw new me({code:"attempted_submit_otp_before_sending",error:"Must `sendCode` with a valid phone number before calling `loginWithCode`"});t({status:"submitting-code"});let w=yield o.auth.phone.loginWithCode(f||r,u,s?"no-signup":"login-or-sign-up");return t({status:"done"}),(v=e==null?void 0:e.onLoginSuccess)==null||v.call(e,w.user,w.is_new_user),w==null?void 0:w.user}catch(k){i(k)}}),[a,o,r,i,e==null?void 0:e.onLoginSuccess]);return{sendCode:l,loginWithCode:y,state:n}};import*as O from"expo-linking";import{useCallback as q,useContext as Ae,useRef as Re}from"react";import{PrivyClientError as C}from"@privy-io/js-sdk-core";var ht=e=>{let{appState:r,getCurrentAppState:c}=M(),{client:a,user:o,farcasterState:n,setFarcasterState:t}=Ae(h),i=Re(!1),l=q(f=>{var d;let s=g(f);return t({status:"error",error:s}),(d=e==null?void 0:e.onError)==null||d.call(e,s),s},[e==null?void 0:e.onError,t]),y=q(()=>{i.current=!0},[]);return{linkWithFarcaster:q((v,...k)=>m(void 0,[v,...k],function*({relyingParty:f,redirectUrl:s},d={pollAttempts:10,pollIntervalMs:1e3}){var w;try{if(i.current=!1,!o)throw new C({code:"attempted_link_farcaster_before_logged_in",error:"Must be logged in to link a Farcaster account."});t({status:"generating-uri"});let{connect_uri:b,channel_token:S}=yield a.auth.farcaster.initializeAuth({relyingParty:f,redirectUrl:O.createURL(s!=null?s:"/")});if(!b)throw new C({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!S)throw new C({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield O.openURL(b),t({status:"polling-status"});let E=0;for(;E<d.pollAttempts;){if(i.current)throw new C({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(r.current!=="active"&&c()!=="active"){yield _(d.pollIntervalMs);continue}let W=yield a.auth.farcaster.getFarcasterStatus({channel_token:S});if(W.state==="completed"){t({status:"submitting-token"});let P=yield a.auth.farcaster.link(p({channel_token:S},W));return t({status:"done"}),(w=e==null?void 0:e.onSuccess)==null||w.call(e,P),P}E++,yield _(d.pollIntervalMs)}throw new C({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(b){throw l(b)}}),[a,e==null?void 0:e.onSuccess,l,t,o]),state:n,cancel:y}};import{useCallback as he,useContext as Fe}from"react";var kt=e=>{let{client:r}=Fe(h),c=he(o=>{var t;let n=g(o);return(t=e==null?void 0:e.onError)==null||t.call(e,n),n},[e==null?void 0:e.onError]);return{unlinkFarcaster:he(n=>m(void 0,[n],function*({fid:o}){var t;try{let i=yield r.auth.farcaster.unlink({fid:o});return(t=e==null?void 0:e.onSuccess)==null||t.call(e,i),i}catch(i){throw c(i)}}),[r,e==null?void 0:e.onSuccess,c])}};import*as A from"expo-linking";import{useCallback as J,useContext as Ie,useRef as Te}from"react";import{PrivyClientError as x}from"@privy-io/js-sdk-core";var Pt=e=>{let{appState:r,getCurrentAppState:c}=M(),{client:a,user:o,farcasterState:n,setFarcasterState:t}=Ie(h),i=Te(!1),l=J(f=>{var d;let s=g(f);return t({status:"error",error:s}),(d=e==null?void 0:e.onError)==null||d.call(e,s),s},[e==null?void 0:e.onError,t]),y=J(()=>{i.current=!0},[]);return{loginWithFarcaster:J((k,...w)=>m(void 0,[k,...w],function*({relyingParty:f,redirectUrl:s,disableSignup:d},v={pollAttempts:10,pollIntervalMs:1e3}){var b;try{if(i.current=!1,o)throw new x({code:"attempted_login_with_farcaster_while_already_logged_in",error:"Already logged in, use `useLinkWithFarcaster` if you are trying to link farcaster to an existing account"});t({status:"generating-uri"});let{connect_uri:S,channel_token:E}=yield a.auth.farcaster.initializeAuth({relyingParty:f,redirectUrl:A.createURL(s!=null?s:"/")});if(!S)throw new x({code:"failed_to_generate_farcaster_uri",error:"Failed to generate farcaster uri"});if(!E)throw new x({code:"failed_to_generate_farcaster_channel_token",error:"Failed to generate farcaster channel token"});yield A.openURL(S),t({status:"polling-status"});let W=0;for(;W<v.pollAttempts;){if(i.current)throw new x({code:"farcaster_polling_canceled",error:"Farcaster polling canceled"});if(r.current!=="active"&&c()!=="active"){yield _(v.pollIntervalMs);continue}let P=yield a.auth.farcaster.getFarcasterStatus({channel_token:E});if(P.state==="completed"){t({status:"submitting-token"});let F=yield a.auth.farcaster.authenticate(p({channel_token:E,mode:d?"no-signup":"login-or-sign-up"},P));return t({status:"done"}),(b=e==null?void 0:e.onSuccess)==null||b.call(e,F.user,F.is_new_user),F.user}W++,yield _(v.pollIntervalMs)}throw new x({code:"farcaster_polling_timeout",error:"Farcasting polling timed out"})}catch(S){throw l(S)}}),[a,l,e==null?void 0:e.onSuccess,t,o,r]),state:n,cancel:y}};import{useCallback as ye,useContext as He}from"react";var Ot=e=>{let{client:r}=He(h),c=ye(o=>{var t;let n=g(o);return(t=e==null?void 0:e.onError)==null||t.call(e,n),n},[e==null?void 0:e.onError]);return{unlinkOAuth:ye(t=>m(void 0,[t],function*({provider:o,subject:n}){var i;try{let l=yield r.auth.oauth.unlink(o,n);return(i=e==null?void 0:e.onSuccess)==null||i.call(e,l),l}catch(l){throw c(l)}}),[r,e==null?void 0:e.onSuccess,c])}};import{useContext as Ge,useEffect as Be,useRef as Ne}from"react";var Tt=e=>{let{client:r}=Ge(h),c=Ne(e.onOAuthTokenGrant);c.current=e.onOAuthTokenGrant,Be(()=>{let{unsubscribe:a}=r.addOAuthTokensListener(o=>{c.current(o)});return a},[r])};import{useCallback as je,useContext as qe}from"react";import{getUserEmbeddedEthereumWallet as Ke,getUserEmbeddedSolanaWallet as De,PrivyClientError as U,throwIfInvalidRecoveryUpgradePath as Je}from"@privy-io/js-sdk-core";var Kt=()=>{let{user:e,client:r}=qe(h);return{setRecovery:je(a=>m(void 0,null,function*(){var i;let o=r.app.appId;if(!e)throw new U({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let n=(i=Ke(e))!=null?i:De(e);if(!n)throw new U({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});try{n.chain_type==="ethereum"?yield r.embeddedWallet.getProvider(n):n.chain_type==="solana"&&(yield r.embeddedWallet.getSolanaProvider(n,n.address,"solana-address-verifier"))}catch(l){throw new U({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}Je({currentRecoveryMethod:n.recovery_method,upgradeToRecoveryMethod:a.recoveryMethod});let t=yield Ve({appId:o,client:r,user:e,primaryAccount:n,recoveryParams:a});try{let{user:l}=yield r.embeddedWallet.setRecovery(t);return{user:l}}catch(l){throw new U({code:"embedded_wallet_set_recovery_error",error:l instanceof Error?l.message:"Error setting password on embedded wallet"})}}),[r,e])}},Ve=n=>m(void 0,[n],function*({appId:e,client:r,user:c,primaryAccount:a,recoveryParams:o}){switch(o.recoveryMethod){case"user-passcode":return te(p({},o),{wallet:a});case"google-drive":{let t=yield L(r);return{recoveryMethod:"google-drive",wallet:a,recoveryAccessToken:t}}case"icloud":{let{recoverySecret:t,iCloudRecordName:i}=yield oe({appId:e,client:r,user:c});return{recoveryMethod:"icloud-native",recoverySecretOverride:t,iCloudRecordNameOverride:i,wallet:a}}default:throw new U({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}});import{useCallback as $e,useContext as ze}from"react";import{getUserEmbeddedEthereumWallet as Qe,getUserEmbeddedSolanaWallet as Xe,PrivyClientError as V}from"@privy-io/js-sdk-core";var Yt=()=>{let{user:e,client:r}=ze(h);return{recover:$e(a=>m(void 0,null,function*(){var l;if(!e)throw new V({code:"embedded_wallet_recovery_error",error:"User must be loaded before attempting to modify the recovery method."});let o=(l=Qe(e))!=null?l:Xe(e);if(!o)throw new V({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let n,t,i;switch(a.recoveryMethod){case"user-passcode":n=a.password;break;case"google-drive":t=yield L(r);break;case"icloud":let{recoverySecret:y}=yield ne({client:r,walletAddress:o.address,chainType:o.chain_type});i=y;break}try{o.chain_type==="ethereum"?yield r.embeddedWallet.getProvider(o,n,t,i):o.chain_type==="solana"&&(yield r.embeddedWallet.getSolanaProvider(o,o.address,"solana-address-verifier",n,t,i))}catch(y){throw new V({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"})}}),[r,e])}};import{useContext as Ye,useEffect as $}from"react";var z=(e={})=>{let{wallet:r,createWalletCallbacks:c,recoverWalletCallbacks:a,setWalletRecoveryCallbacks:o}=Ye(h),{onCreateWalletSuccess:n,onCreateWalletError:t,onRecoverWalletError:i,onRecoverWalletSuccess:l,onSetWalletRecoverySuccess:y,onSetWalletRecoveryError:u}=e;return $(()=>{c.current={onSuccess:n,onError:t}},[n,t]),$(()=>{a.current={onSuccess:l,onError:i}},[l,i]),$(()=>{o.current={onSuccess:y,onError:u}},[l,i]),r};import{useEffect as Ze}from"react";var ao=({onStateChange:e})=>{let r=z();return Ze(()=>{e(r)},[r])};import{useContext as er}from"react";var uo=()=>{let{getIdentityToken:e}=er(h);return{getIdentityToken:e}};import{useCallback as fe,useContext as rr}from"react";import{PrivyClientError as tr}from"@privy-io/js-sdk-core";var wo=e=>{let{user:r,client:c}=rr(h),a=fe(n=>{var i;let t=g(n);return(i=e==null?void 0:e.onError)==null||i.call(e,t),t},[e==null?void 0:e.onError]);return{create:fe(()=>m(void 0,null,function*(){var n;try{if(r)throw new tr({code:"attempted_to_create_guest_account_for_logged_in_user",error:"Already logged in, you cannot create a guest account"});let t=yield c.auth.guest.create();return(n=e==null?void 0:e.onSuccess)==null||n.call(e,t.user,t.is_new_user),t.user}catch(t){throw a(t)}}),[c,a,r,e==null?void 0:e.onSuccess])}};import{useContext as or,useEffect as nr}from"react";function Eo({onMfaRequired:e}){let{client:r,user:c}=or(h);nr(()=>{function a(){return m(this,null,function*(){var o;yield e((o=c==null?void 0:c.mfa_methods.map(({type:n})=>n))!=null?o:[])})}return r.mfaPromises.on("mfaRequired",a),()=>{r.mfaPromises.off("mfaRequired",a)}},[r,c,e])}import{useCallback as Q,useContext as ir}from"react";import{PrivyClientError as R}from"@privy-io/js-sdk-core";function Uo(){let{client:e,mfaConfig:r}=ir(h),c=Q(n=>m(this,null,function*(){switch(n.method){case"sms":yield e.mfa.sms.sendCode({action:"verify"});return;case"passkey":let{options:t}=yield e.mfa.passkey.generateAuthenticationOptions({relying_party:n.relyingParty||(r==null?void 0:r.relyingParty)});return se(t);case"totp":return;default:throw new Error(`Unsupported MFA method: ${n.mfaMethod}`)}}),[e,r==null?void 0:r.relyingParty]),a=Q(n=>m(this,null,function*(){var t,i,l;switch(n.method){case"totp":case"sms":if(typeof n.mfaCode!="string")throw new R({code:"invalid_mfa_code",error:"Invalid MFA code"});(t=e.mfaPromises.rootPromise.current)==null||t.resolve({mfaMethod:n.method,mfaCode:n.mfaCode,relyingParty:n.relyingParty||(r==null?void 0:r.relyingParty)||""}),yield new Promise((s,d)=>{e.mfaPromises.submitPromise.current={resolve:s,reject:d}});break;case"passkey":if(typeof n.mfaCode=="string")throw new R({code:"invalid_passkey_response",error:"Invalid authenticator response"});let y=yield ie(n.mfaCode),u=ae(y);(i=e.mfaPromises.rootPromise.current)==null||i.resolve({mfaMethod:n.method,relyingParty:n.relyingParty||"",mfaCode:u}),yield new Promise((s,d)=>{e.mfaPromises.submitPromise.current={resolve:s,reject:d}});break;default:let f=new R({code:"unsupported_mfa_method",error:"Unsupported MFA method"});throw(l=e.mfaPromises.rootPromise.current)==null||l.reject(f),f}}),[e,r==null?void 0:r.relyingParty]),o=Q(()=>{var n;(n=e.mfaPromises.rootPromise.current)==null||n.reject(new R({code:"mfa_canceled",error:"MFA canceled"}))},[e]);return{init:c,submit:a,cancel:o}}import{useCallback as X,useContext as ar}from"react";function Ro(){let{client:e}=ar(h),r=X(o=>m(this,null,function*(){switch(o.method){case"sms":case"totp":return yield e.mfa.initEnrollMfa(o);case"passkey":return;default:throw new Error(`Unsupported MFA method: ${o.mfaMethod}`)}}),[e]),c=X(o=>m(this,null,function*(){switch(o.method){case"sms":case"totp":case"passkey":yield e.mfa.submitEnrollMfa(o);return;default:throw new Error(`Unsupported MFA method: ${o.mfaMethod}`)}}),[e]),a=X(o=>m(this,null,function*(){switch(o.method){case"sms":case"totp":yield e.mfa.unenrollMfa(o.method);return;case"passkey":yield e.mfa.submitEnrollMfa({method:"passkey",credentialIds:[]});return;default:throw new Error(`Unsupported MFA method: ${o.method}`)}}),[e]);return{initMfaEnrollment:r,submitMfaEnrollment:c,unenrollMfa:a}}import{useContext as sr,useEffect as ge}from"react";var cr=(e={})=>{let{solanaWallet:r,createSolanaWalletCallbacks:c,recoverSolanaWalletCallbacks:a}=sr(h),{onCreateWalletSuccess:o,onCreateWalletError:n,onRecoverWalletError:t,onRecoverWalletSuccess:i}=e;return ge(()=>{c.current={onSuccess:o,onError:n}},[o,n]),ge(()=>{a.current={onSuccess:i,onError:t}},[i,t]),r};import{useContext as lr}from"react";var Y=()=>{let{user:e,isReady:r,logout:c,getAccessToken:a,error:o}=lr(h);return{user:e,isReady:r,error:o,logout:c,getAccessToken:a}};import{useContext as dr}from"react";var Z=()=>{let{client:e}=dr(h);return e};import{useCallback as ur,useMemo as mr}from"react";import{getAllUserEmbeddedBitcoinWallets as ee,getUserEmbeddedEthereumWallet as we,getUserEmbeddedSolanaWallet as ve,PrivyClientError as re}from"@privy-io/js-sdk-core";var hr=()=>{let{user:e}=Y(),r=Z(),c=mr(()=>{var l;let o=(l=we(e))!=null?l:ve(e);if(!o)return[];let n=ee(e),{entropyId:t,entropyIdVerifier:i}=I(o);return n.map(y=>({address:y.address,walletIndex:y.wallet_index,publicKey:y.public_key,chainType:y.chain_type,getProvider:()=>r.embeddedWallet.getBitcoinProvider({wallet:y,entropyId:t,entropyIdVerifier:i})}))},[r,e]),a=ur(t=>m(void 0,[t],function*({chainType:o,createAdditional:n=!1}){var k;let{user:i}=yield r.user.get(),l=(k=we(i))!=null?k:ve(i);if(!l)throw new re({code:"embedded_wallet_creation_error",error:"No existing wallet for this user, create an Ethereum walet first to add a Bitcoin wallet"});let{entropyId:y,entropyIdVerifier:u}=I(l),f=ee(i).filter(w=>w.chain_type===o);if(!n&&f.length>0)throw new re({code:"embedded_wallet_creation_error",error:"Wallet already exists for this user. Set `createAdditional` to `true` to create another wallet"});let s=f.length===0?0:Math.max(...f.map(w=>w.wallet_index),0)+1,d=yield r.embeddedWallet.add({chainType:o,hdWalletIndex:s,entropyId:y,entropyIdVerifier:u}),v=ee(d.user).find(w=>w.chain_type===o&&w.wallet_index===s);if(!d.user||!v)throw new re({code:"embedded_wallet_creation_error",error:"Unknown error creating wallet"});return{user:d.user,provider:yield r.embeddedWallet.getBitcoinProvider({wallet:v,entropyId:y,entropyIdVerifier:u})}}),[r]);return{wallets:c,create:a}};export{vr as a,Wr as b,Or as c,Gr as d,Jr as e,Zr as f,at as g,ht as h,kt as i,Pt as j,Ot as k,Tt as l,Kt as m,Yt as n,z as o,ao as p,uo as q,wo as r,Eo as s,Uo as t,Ro as u,cr as v,Y as w,Z as x,hr as y};
