import{a as q,b as N,c as V,d as D,e as J,f as U,g as I,h as M}from"./chunk-QSWCX5XI.js";import{F as _,I as b,J as C,a as S,b as x,d as h,i as g}from"./chunk-2HSCQXHK.js";import{useCallback as R,useContext as H}from"react";import{PrivyClientError as K}from"@privy-io/js-sdk-core";var G=e=>{let{user:m,client:i,passkeyState:P,setPasskeyState:s}=H(_),u=R(a=>{var n;let o=g(a);return s({status:"error",error:o}),(n=e==null?void 0:e.onError)==null||n.call(e,o),o},[e==null?void 0:e.onError]);return{linkWithPasskey:R(o=>h(void 0,[o],function*({relyingParty:a}){var n,l,y,k,r,d,c,f,p;try{if(!m)throw new K({code:"attempted_link_passkey_before_logged_in",error:"Must be logged in to link a passkey."});s({status:"generating-challenege"});let{options:t}=yield i.auth.passkey.generateRegistrationOptions(a);s({status:"awaiting-passkey"});let W=yield b({rp:t.rp,user:{id:t.user.id,name:t.user.name,displayName:t.user.display_name},challenge:t.challenge,pubKeyCredParams:t.pub_key_cred_params,extensions:{hmacCreateSecret:(n=t.extensions)==null?void 0:n.hmac_create_secret,credProps:(y=(l=t.extensions)==null?void 0:l.cred_props)==null?void 0:y.rk,appid:(k=t.extensions)==null?void 0:k.app_id},attestation:t.attestation,excludeCredentials:t.exclude_credentials,authenticatorSelection:{authenticatorAttachment:(r=t.authenticator_selection)==null?void 0:r.authenticator_attachment,residentKey:(d=t.authenticator_selection)==null?void 0:d.resident_key,userVerification:(c=t.authenticator_selection)==null?void 0:c.user_verification,requireResidentKey:(f=t.authenticator_selection)==null?void 0:f.require_resident_key}});s({status:"submitting-response"});let w=yield i.auth.passkey.linkWithPasskey(W,a);return s({status:"done"}),(p=e==null?void 0:e.onSuccess)==null||p.call(e,w),w}catch(t){throw u(t)}}),[m,i,u,e==null?void 0:e.onSuccess]),state:P}};import{useCallback as E,useContext as v}from"react";import{PrivyClientError as L}from"@privy-io/js-sdk-core";var ee=e=>{let{user:m,client:i,passkeyState:P,setPasskeyState:s}=v(_),u=E(a=>{var n;let o=g(a);return s({status:"error",error:o}),(n=e==null?void 0:e.onError)==null||n.call(e,o),o},[e==null?void 0:e.onError]);return{loginWithPasskey:E(o=>h(void 0,[o],function*({relyingParty:a}){var n,l,y,k;try{if(m)throw new L({code:"attempted_login_with_passkey_while_already_logged_in",error:"Already logged in, use `useLinkWithPasskey` if you are trying to link a passkey to an existing account"});s({status:"generating-challenege"});let{options:r}=yield i.auth.passkey.generateAuthenticationOptions(a);s({status:"awaiting-passkey"});let d=yield C({challenge:r.challenge,rpId:r.rp_id,extensions:{appid:(n=r.extensions)==null?void 0:n.app_id,credProps:(l=r.extensions)==null?void 0:l.cred_props,hmacCreateSecret:(y=r.extensions)==null?void 0:y.hmac_create_secret},timeout:r.timeout,allowCredentials:r.allow_credentials,userVerification:r.user_verification});s({status:"submitting-response"});let c=yield i.auth.passkey.loginWithPasskey(x(S({},d),{clientExtensionResults:{}}),r.challenge,a);return s({status:"done"}),(k=e==null?void 0:e.onSuccess)==null||k.call(e,c.user,c.is_new_user),c.user}catch(r){throw u(r)}}),[i,u,e==null?void 0:e.onSuccess]),state:P}};export{I as hasError,q as isConnected,V as isConnecting,U as isCreating,D as isDisconnected,J as isNotCreated,N as isReconnecting,M as needsRecovery,G as useLinkWithPasskey,ee as useLoginWithPasskey};
